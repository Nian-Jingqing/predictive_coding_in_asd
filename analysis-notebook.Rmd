---
title: "Data Analysis of Predictive coding in ASD"
author: "Z. Shi, L. Theisinger, F. Allenmark, R. Pistorius, H. MÃ¼ller, C. Falter-Wagner"
output: html_notebook
---

# Abstract

Individuals with autism spectrum disorder (ASD) have been widely reported to show atypicalities in predictive coding, though there remains a controversy regarding what causes such atypical processing. Suggestions range from overestimation of volatility to rigidity in the reaction to environmental changes. Here, we tested two accounts directly using duration reproduction of volatile and non-volatile interval sequences. Critically, both sequences had the same set of intervals but differed in their stimulus presentation orders. Comparing individuals with ASD vs. their matched controls, we found both groups to respond to the volatility in a similar manner, albeit with a generally reduced prior in the ASD group. Interestingly, though, relative to the control group, the ASD group exhibited a markedly reduced trust in the prior in the volatile trial session when this was performed after the non-volatile session, while both groups performed comparably in the reverse session order. Our findings suggest that it is not the learning of environmental volatility that is compromised in ASD. Rather, it is their response to a change of the volatility regimen from stable to volatile, which causes a highly inflexible weighting of prediction errors.

# Data Structure

1. `/experiments`: Experimental codes and instructions

This sub-folder contains Matlab codes and instructions for the duration reproduction task. The sequences of the duration reproductions are stored in the sub-folder `/experiments/seqs`. Those sequences were used for matched participants. 

2. `/data`: raw data files

- `rawdata.csv`: Raw reproduction trials
- `aq.csv`: Measured AQ scores from individual participants. 

3. `/figures`: store figures used in the paper. 

# Data Analysis

## 1. load raw data
```{r packages, message=FALSE, warning=FALSE, include=FALSE}
# load packages
library(tidyverse)
library(ez)
library(cowplot)
library(BayesFactor) # in case need Bayes factor analysis
library(bayestestR)
library(rstatix) # using tidyverse friendly statistics

# ---- read data and preparation -----
rawdata = read_csv('./data/rawdata.csv')
aq = read_csv("./data/aq.csv")

# flag
saveFig = FALSE
```

Show the raw trial structure: 
```{r raw trial structure}
glimpse(rawdata)

```
In the raw trials, there are several important columns which are relevant for  further analyses. 

- `Duration`: The test durations generated by computer. 'pdur' is the actual presented durations by the computer. There were some fluctuations, but within 5 ms (within 1 refresh frame). 
- `sub`, `group`, `sequence` are anonymized subject number, group and the duration sequence used in the experiment. 
- `Reproduction`, `rep_err`: the reproduced durations and the reproduction errors compared to the given duration. 
- `itd`, `preDuration`: the inter-trial difference in  a given trial, and the duration used in the previous trial. These were used in the sequential effect analysis. 

## The sampled durations and sequences

Let's first illustrate the sequence and the distribution of the durations. 

```{r sequence}
# ---- illustrate one sequence -----
fig11 = ggplot(rawdata, aes(Duration)) + geom_histogram(binwidth = 0.1, fill = I("white"), col = I('black')) + 
  theme_classic() + xlab('Duration (secs)')

# a typical sequence
sub1 = rawdata %>% filter(sub == 'ara27')
fig12 = ggplot(sub1, aes(trlNo, Duration, color = session)) + geom_line() + 
  xlab("Trial Sequence") + theme_classic()+
  theme(legend.position = 'top')

fig1 = plot_grid(fig11,fig12, labels = c("a","b"))
fig1 
if (saveFig){
  ggsave("figures/fig_sequence.png", fig1, width=9, height=3.5)
  ggsave("figures/fig_sequence.pdf", fig1, width=9, height=3.5)
}
```
We then average the mean reproduction for further analyses
```{r meanRepr}

# mean analysis
mrep =  rawdata %>% filter(Reproduction > Duration/3, Reproduction < 3*Duration) %>% # filter outliers
  group_by(sub, group,sequence, session, Duration) %>%
  summarise(mRep = mean(Reproduction), sdr=sd(Reproduction), n = n(), 
            se = sd(Reproduction)/sqrt(n-1)) 
tail(mrep)
```

## Outlier screening 

With individual screening, we found two outliers in the ASD group who produced extreme different pattern from the rest of the group. Their reproduced durations were roughly 'flat' across the whole probe range in the high-volatility session, while showing a comparable pattern to other ASD and TD individuals in the low-volatility session. 
```{r outliers}
# ---- plot both outliers  ----
fig_outlier = mrep%>% 
  filter(n>5, sub %in% c('aril02', 'arm13')) %>% 
  ggplot(aes(Duration, mRep, color = session, group = session, shape = session)) + 
  geom_point(size = 2) + geom_line(aes(linetype = session)) + 
  geom_errorbar(aes(ymin = mRep - se, ymax = mRep +se), width = 0.05) + 
  facet_wrap(~sub) +
  theme_classic() + #theme(legend.pos = 'bottom') +
  geom_abline(slope = 1, linetype = 2) + 
  xlab('Duration (Secs)') + ylab('Mean Reproduction (Secs)') + 
  theme(strip.background = element_blank(), strip.text.x = element_blank())
fig_outlier
if (saveFig){
  ggsave("figures/fig_outlier.png", fig_outlier, width=9, height=4)
  ggsave("figures/fig_outlier.pdf", fig_outlier, width=9, height=4)
}
```
## Typical reproduction performance 

And here are the two typical participants produced errors from sequence 12:
```{r typical participants}
# ---- reproduction figure - an example -----
# reproduction error
fig_repd = mrep%>% 
  filter(n>5, sequence == '12') %>% 
  ggplot(aes(Duration, mRep-Duration, color = session, group = session, shape = session)) + 
  geom_point(size = 2) + 
  #geom_line(aes(linetype = session)) + 
  geom_smooth(method = 'lm', aes(fill = session)) +
  geom_errorbar(aes(ymin = mRep-Duration - se, ymax = mRep-Duration +se), width = 0.05) + 
  theme_classic() + theme(strip.background = element_blank()) +
  geom_abline(slope = 1, linetype = 2) + 
  facet_wrap(~group) + theme(legend.position = 'bottom') +
  xlab('Duration (Secs)') + ylab('Reproduction Errors (Secs)')

# show reproduction errors
fig_repd

if(saveFig){
  ggsave("figures/fig_reproduction.png", fig_repd, width=7, height=4)
  ggsave("figures/fig_reproduction.pdf", fig_repd, width=7, height=4)
}
```

As we can see from the patterns above. The ASD participant produced relative flat errors, while the TD participant showed a strong central tendency effect (shorts being overestimated and longs being underestimated). 

## Estimate Central tendency and sequential dependence

In the following analysis, we exclude the above two outliers and their matched controls from the rest analyses. 

```{r refine_valid_data}
# ----- separate two outliers -----
vdata = rawdata %>% 
  filter(! (sequence %in% c(2,13))) %>% # separate two outliers
  filter(Reproduction > Duration/3, Reproduction < 3*Duration) 

# for robust regression, we remove those durations probe without repetition 
vdata %>% group_by(sub, Duration, session) %>% summarise(n=n()) -> cnt
vdata = left_join(vdata, cnt, by = c("sub","Duration","session")) %>% 
  filter(n>1)

#print number of valid subjects
length(unique(vdata$sub))
```
Now let's estimate the central tendency effect, serial dependence effect using linear regression, and general bias as compared to the mean of the sample duration. 

Given that the session order is also an important factor, we generate this factor by the test sequence. 

```{r linear_models}
# using error for regression, -slope is the central tendency index. 
ct_model <- function(df){
  lm(rep_err ~ Duration, data = df)
}

# sequential effect using the duration from the previous trial
seq_model <- function(df){
  lm(rep_err ~ preDuration, data = df)
}

# calculate the order of the sequence
subSeq = rawdata %>% filter(trlNo %in% c(1,251)) %>% select(sub, session, trlNo) %>%
  spread(session, trlNo) %>% mutate(Order = if_else(`High Vola.` ==1, "HV First",'LV First')) %>%
  ungroup() %>%  select(sub, Order)

# calculate slope for the central tendency as well as the sequential dependence. 
slopes_ct <- vdata %>% group_by(sub, sequence, session, group) %>%
  nest()  %>%  # nested data
  mutate(model = map(data, ct_model)) %>%  # linear regression
  mutate(slope = map(model, broom::tidy)) %>%  # get estimates out
  unnest(slope, .drop = TRUE) %>% # remove raw data
  select(-std.error,-statistic, -p.value) %>%  # remove unnecessary columns
  spread(term, estimate) %>%   # spread estimates
  rename(intercept_ct = `(Intercept)`, slope = Duration)

#sequential effect
slopes_seq <- vdata %>% filter(!is.na(preDuration)) %>%
  group_by(sub, sequence, session, group) %>%
  nest()  %>%  # nested data
  mutate(model = map(data, seq_model)) %>%  # linear regression
  mutate(slope = map(model, broom::tidy)) %>%  # get estimates out
  unnest(slope, .drop = TRUE) %>% # remove raw data
  select(-std.error,-statistic, -p.value) %>%  # remove unnecessary columns
  spread(term, estimate) %>%   # spread estimates
  rename(intercept_seq = `(Intercept)`, seq_slope = preDuration)

# merge two tables together
slopes_all = left_join(slopes_ct, slopes_seq, by = c("sub", "sequence", "session","group")) %>%
  select(-data.x, -model.x, -data.y, -model.y) %>% mutate(ci = -slope, si = seq_slope) %>% #central tendency index
  left_join(., subSeq, by = 'sub')

# estimated general biases (over-/under-estimates)

# individual mean interval (middle point)
mInterval  = vdata %>% group_by(sub) %>%  summarise(mDur = mean(Duration))

# join the mean interval, and estimate the general bias
vslopes = slopes_all %>% left_join(., mInterval, by = c('sub')) %>% 
  mutate(gBias = (intercept_ct + slope * mDur)*1000) %>% # add AQ
  left_join(., aq, by = c('sub'))

# change factor order for plotting
vslopes$session = factor(vslopes$session, levels  = c("Low Vola.", "High Vola."))
vslopes$Order = factor(vslopes$Order)
vslopes$group = factor(vslopes$group)

head(vslopes)
```

### Visulize CTE and sequential dependence

Let's visualize the biases (central tendency and serial dependence) for two groups (ASD vs. TD)

```{r plot_biases}
pd = position_dodge(width = 0.05)

# plot CTI and serial dependence together
fig_biases = vslopes%>% 
  group_by(group, session, Order) %>% 
  summarise(msi = mean(si), n = n(), se_si = sd(si)/sqrt(n),
            mci = mean(ci), se_ci = sd(ci)/sqrt(n)) %>%
  ggplot(aes(msi, mci, color = group, shape = session, 
              group=interaction(Order, group))) + 
  geom_hline(yintercept = 0, color = 'gray', linetype = 'dashed') + 
  geom_vline(xintercept = 0, color = 'gray', linetype = 'dashed') + 
  geom_point(size = 2) + 
  geom_line(aes(linetype = Order)) + 
  geom_errorbar(aes(ymin = mci - se_ci, ymax = mci + se_ci), width = 0.01 ) + 
  geom_errorbarh(aes(xmin = msi - se_si, xmax = msi + se_si), height = 0.01) + 
  xlab('Serial Dependence') + ylab('Central Tendency') + 
  scale_y_continuous(labels = scales::percent) + 
  scale_x_continuous(labels = scales::percent) + 
  guides(color = guide_legend(title = 'Group'), 
         linetype = guide_legend(title = 'Session Order'),
         ) +
  theme_classic() +
  theme(legend.position = 'bottom')
fig_biases
if (saveFig){
  ggsave("figures/fig_biases.png", fig_biases, width=5, height=4)
  ggsave("figures/fig_biases.pdf", fig_biases, width=5, height=4)
}


```

By visual inspection, individuals with ASD exhibited less central tendency relative to their matched TD controls (the red lines below the cyan lines in the above figure), while the local serial dependence was relatively comparable between two groups except in the low volatility condition when that condition started first. Interestingly, the central tendency and serial dependence were similar for both groups when the high-volatility session started first (the solid lines), while they differed when the low-volatility session started first (the dashed lines). 

Given that the main difference was shown in CTE. We further plot the mean CTEs. 

```{r}
pd = position_dodge(width = 0.5)
# separate plots for appendix
fig_cti = vslopes %>% 
  group_by(group, session, Order) %>% 
  summarise(mci = mean(ci), n = n(), se = sd(ci)/sqrt(n)) %>%
  ggplot(aes(session, mci, fill = group, color = group)) + 
  geom_bar(stat = 'identity', position = pd, width = 0.5) + facet_wrap(~Order)+
  geom_errorbar(aes(ymin = mci - se, ymax = mci + se), width = 0.2, position = pd) + 
  theme_classic() + theme(legend.position = 'bottom', strip.background = element_blank()) +
  xlab('Session') + ylab('Central Tendency Index') + 
  scale_y_continuous(labels = scales::percent) + 
  guides(color = guide_legend(title = 'Group'), linetype = guide_legend(title = 'Session Order'))
fig_cti
if (saveFig){
  ggsave("figures/fig_cte.png", fig_cti, width=4, height=4)
  ggsave("figures/fig_cte.pdf", fig_cti, width=4, height=4)
  fig4 = plot_grid(fig_biases, fig_cti, nrow = 1, labels = c("a","b"))
  ggsave('figures/fig4.pdf',fig4, width = 8, height = 4)
}


```


### Statistics

1. Central tendency effect

```{r ANOVAs_cti}
# ---- central tendency index----
# repeated measures ANOVA on central tendency index
anova1 = ezANOVA(data = vslopes, dv = ci, 
                 wid = sub, 
                 within = .(session),
                 between = .(group, Order))
anova1$ANOVA

## separate for session order
anova1a = ezANOVA(data = vslopes %>% filter(Order == 'LV First'), 
                  dv = ci, 
                  wid = sub, 
                  within = .(session),
                  between = .(group))
anova1a$ANOVA

anova1b = ezANOVA(data = vslopes %>% filter(Order == 'HV First'), 
                  dv = ci, 
                  wid = sub, 
                  within = .(session),
                  between = .(group))
anova1b$ANOVA

```

2. Bayes factor analysis for pair-wise comparison

The above analysis showed that the main difference came from the central tendency in the LV-first subgroups. Here we further get the central tendency bias and Bayes factor analyses:
```{r cti_bayes}

# --- Bayes t-tests
bftest = function(df){
  df = as.data.frame(df)
  # get the means
  rdf = df%>% summarise(mci = mean(ci), 
                        se_ci = sd(ci)/sqrt(n()),
                        msi = mean(si), 
                        se_si = sd(si)/sqrt(n()))
  rdf$ci_bf = ttestBF(df$ci, mu = 0) %>% extractBF() %>% .$bf
  rdf$si_bf = ttestBF(df$si, mu = 0) %>% extractBF() %>% .$bf
  return(rdf)
}

vslopes %>% group_by(group, session, Order) %>% nest() %>%
  mutate(bf = map(data, bftest)) %>% unnest(bf, .drop = TRUE)

# group comparison for the low-vol-first, high-vol session
vslopes %>% filter(session == 'High Vola.', Order == 'LV First') %>% as.data.frame() ->v11
t_test(data = v11, formula = ci ~ group) 
ttestBF(data = v11, formula = ci ~ group)

vslopes %>% filter(session == 'Low Vola.', Order == 'LV First') %>% as.data.frame() ->v12
t_test(data = v12, formula = ci ~ group) 
ttestBF(data = v12, formula = ci ~ group)
```


3. ANOVA analyses for the serial dependence indices:

```{r ANOVAs_sdi}
# ---- Serial dependence index----
anova2 = ezANOVA(data = vslopes, dv = si, 
                 wid = sub, 
                 within = .(session),
                 between = .(group, Order))
anova2$ANOVA

# Bayes factors
bf = anovaBF(si ~ session + group + Order, data = vslopes, whichRandom = "sub")
bayesfactor_inclusion(bf) #bayes inclusion values

## separate for session order
anova2a = ezANOVA(data = vslopes %>% filter(Order == 'LV First'), 
                  dv = si, 
                  wid = sub, 
                  within = .(session),
                  between = .(group))
anova2a$ANOVA

anova2b = ezANOVA(data = vslopes %>% filter(Order == 'HV First'), 
                  dv = si, 
                  wid = sub, 
                  within = .(session),
                  between = .(group))
anova2b$ANOVA

```



4. General biases

Additionally we examined the general biases:
```{r gBias}
# ---- descriptive of general bias ----
vslopes %>% group_by(group) %>% summarise(mg = mean(gBias), se = sd(gBias)/sqrt(n())) 

# ANOVA shows no differences
anova2 = ezANOVA(data = vslopes, dv = gBias, 
                 wid = sub, 
                 within = .(session),
                 between = .(group, Order))
anova2$ANOVA

bf = anovaBF(ci ~  group + session + Order, 
             data = as.data.frame(vslopes), whichRandom = "sub")
bayesfactor_inclusion(bf) #bayes inclusion values


```
We then visualize the general biases
```{r plotgBias}
# --- general bias
fig_bias = vslopes %>% group_by(group, session, Order) %>%
  summarise(mbias = mean(gBias), n = n(), se = sd(gBias)/sqrt(n)) %>%
  ggplot(aes(session, mbias, color = Order,linetype = group, group = interaction(Order, group), shape = group)) + 
  geom_point(size = 3, position = pd) + 
  geom_line(position = pd) +
  geom_errorbar(aes(ymin = mbias - se, ymax = mbias + se), width = 0.2, position = pd) + 
  theme_classic()  + theme(legend.position = 'bottom') + xlab('Session') + 
  ylab('Mean overestimation (ms)') 
fig_bias
```

There was no difference in two groups in general biases, although both groups were positive overestimated. 

Next we examined the reproduced variability:
```{r rep_var}
# ---- Reproduction variability -----
msds_r <- mrep  %>% 
  filter(n>5) %>% 
  group_by(group, session,  sub) %>%
  summarise(msd = mean(sdr), n=n(), msd_se = sd(sdr)/sqrt(n)) 

sd_ANOVA <- ezANOVA(msds_r, dv=msd, wid=sub, between=group, within=session)
sd_ANOVA$ANOVA

mmsds_r <- msds_r %>% summarize(mmsd=mean(msd*1000), n = n(), se = sd(msd*1000)/sqrt(n))

pd = position_dodge(width = 0.5)
fig_sd <- ggplot(mmsds_r, aes(session, mmsd, fill = group, color = group)) + 
  geom_bar(stat = 'identity', position = pd, width = 0.5) + 
  geom_errorbar(aes(ymin = mmsd - se, ymax = mmsd + se), position = pd, width = 0.3) +
  ylab('Mean Standard Deviation (ms)') + xlab('Session') + theme_classic() + 
  coord_cartesian(ylim = c(140, 190)) 
fig_sd

if(saveFig){
  ggsave('figures/fig_sd.png', fig_sd, width=5, height=4)
  ggsave('figures/fig_sd.pdf', fig_sd, width=5, height=4)
}

```

Finally, let's check if there were any correlation to the AQ measure


```{r AQ-corr}

# --- correlation analysis with AQ ----

ggplot(vslopes, aes(AQ, ci, color = group)) + geom_point() + geom_smooth(aes(linetype = group), method = lm, se = FALSE)

ungroup(vslopes) %>% group_by(group) %>% 
  cor_test(ci,AQ)

```

The results showed both were positive correlated, however they were not siginficant. 

